const math=require("mathjs"),fs=require("fs"),{kldivergence:kldivergence,json:json,matrix:matrix}=require("mathjs"),{Console:Console}=require("console");class MeshesFinder{constructor(){}initGraph(e,r,t,o){this.adjacencyMatrix=e,this.incidenceMatrix=r,this.nodes=t,this.branches=o}getLoops(e=2){let r,t={state:!1,reason:[]};if(null==this.adjacencyMatrix&&(t.state=!0,t.reason.push("Empty Adjacency Matrix")),null==this.incidenceMatrix&&(t.state=!0,t.reason.push("Empty Incidence Matrix")),null==this.nodes&&(t.state=!0,t.reason.push("Empty Nodes Names Array")),null==this.branches&&(t.state=!0,t.reason.push("Empty Branches Array")),1==t.state)return{error:t,data:r};var o=-1,n=0,s=1,h=0,l=1,i=3,a=4,d=5;function c(e){console.log(math.format(e,14))}function p(e,r,t){let o=0,n=new Array(t);for(let t=0;t<n.length;t++)n[t]=e._data[0][t]&r._data[0][t],o=1;return{error:o,result:n}}let f=function(e){let r=math.size(e),t=r._data[0],o=r._data[1],n="dense",s=math.divide(5,100);return(o*math.subtract(1,s)<math.pow(t,2)||o*math.sum(1,s)>math.pow(t,2))&&(n="sparse"),c("V = "+t+" | E = "+o),c("Graph Type: "+n),{error:0,vertices:t,edges:o,type:n}}(this.incidenceMatrix);console.time("meshes-finder-duration"),console.log("\nSCRIPT STARTED...\n");let g=new Array,b=new Array,u=!0,y={id:-1},N={id:0},S={id:-1},m={id:0},w=new Array(f.vertices);for(let e=0;e<w.length;e++)w[e]={st:o,branches:[]};let O=JSON.parse(JSON.stringify(w)),A=new Array,J=0,E=h,k=0,v=new Array(f.vertices);do{switch(E){case h:{let e=!1;for(let r=0;r<O.length;r++){const t=O[r];if(-1==t.st){S.id=r,y.id=r,t.st=s,t.blocks=[],O[y.id].blocks[k]=S.id,e=!0;break}}if(e){E=i;for(let e=0;e<v.length;e++)v[e]={hop:e,branches:[]}}else u=!1;break}case i:{let e=JSON.parse(JSON.stringify(w));if(k.length==f.vertices-1)for(let r=0;r<e.length;r++)r!=y.id&&(e[r]={st:s,branches:[]});else{e[S.id]={st:s,branches:[]};for(let r=0;r<O[y.id].blocks.length;r++){const t=O[y.id].blocks[r];t!=y.id&&(e[t]={st:s,branches:[]})}}let r={id:S.id,visitList:e};A.push(r),E=a;break}case a:{let e=!1,r=A.length-1;for(let t=0;t<A[r].visitList.length;t++){const s=A[r].visitList[t];if(s.st==o){N.id=m.id,m.id=t,s.st=n,e=!0;break}}if(e)E=l;else{if(A.pop(),0==A.length){E=h;break}A[A.length-1].visitList[S.id].st=s,O[y.id].blocks.pop(),k--,S.id=O[y.id].blocks.slice(-1).pop(),E=a}break}case l:b=[],J=p(math.row(this.incidenceMatrix,S.id),math.row(this.incidenceMatrix,m.id),f.edges);for(let e=0;e<J.result.length;e++)if(J.result[e]){let r={parentNode:S.id,parentNodeStr:this.nodes[S.id],childNode:m.id,childNodeStr:this.nodes[m.id],branchId:e,branchStr:this.branches[e],pathPos:A.length-1};b.push(r)}if(1==J.error){v[k].branches=b,A[A.length-1].visitList[m.id].branches=JSON.parse(JSON.stringify(b)),b=[],m.id==y.id?E=d:(N.id=S.id,S.id=m.id,k++,O[y.id].blocks[k]=S.id,E=i)}else E.machineState=GET_UNVISITED;break;case d:{let e=new Array;for(let r=0;r<=k;r++)v[r].branches.forEach(t=>{e[r]=v[r].branches});let r=!0;if("0"in e||(r=!1),e.length>0&&1==r){e[0][0].parentNode==e[e.length-1][0].childNode&&g.push(JSON.parse(JSON.stringify(e)))}A[A.length-1].visitList[m.id].st=s,E=a;break}}}while(u);let _={order:[]};for(let e=0;e<=f.vertices;e++)_.order[e]=new Array;let x=JSON.parse(JSON.stringify(_)),M=JSON.parse(JSON.stringify(_)),j=JSON.parse(JSON.stringify(_));for(let e=0;e<g.length;e++){const r=g[e];let t={loop_id:e,hop:[]},o=!1;for(let n=0;n<g[e].length;n++){const s=g[e][n];if(2==r.length&&s.length<2)continue;o=!0;const h={id:0,branches:[]};h.id=n,h.branches=s,s&&t.hop.push(h)}o&&_.order[g[e].length].push(t)}for(let e=2;e<_.order.length;e++){const r=_.order[e];let t=!1;if(r&&r.length)for(let o=0;o<r.length;o++){if(r[o].hop.length!=e){_.order[e].splice(o,1),e--,t=!0;break}}}x.order[2]=JSON.parse(JSON.stringify(_.order[2]));for(let e=3;e<=f.vertices;e++){let r=_.order[e],t=new Array;r.forEach(e=>{let r=e.loop_id,o=new Array;e.hop.forEach(e=>{o.push(e.branches[0].branchStr)}),o.sort(),t.push({id:r,b:o})});let o=new Array,n=new Array;for(let e=0;e<t.length-1;e++){let r=t[e];for(let n=e+1;n<t.length;n++){let e=t[n];JSON.stringify(r.b)==JSON.stringify(e.b)&&(o.push(e),t.splice(n,1),n--)}}t.forEach(t=>{for(let o=0;o<r.length;o++){const s=r[o];t.id==s.loop_id&&(n.push(s),x.order[e].push(_.order[e][o]))}})}let I=new Array;x.order.forEach(e=>{e.forEach(e=>{I.push(e.loop_id)})}),I.filter((e,r)=>I.indexOf(e)===r),I.sort((e,r)=>e-r);let L=_.order[2],T=new Array;L.forEach(e=>{let r=e.loop_id,t=new Array;e.hop[0].branches.forEach(e=>{t.push(e.branchStr)}),t.sort(),T.push({id:r,b:t})}),T.forEach(function(e,r){for(let t=r+1;t<T.length;t++){let r=T[t];JSON.stringify(e.b)==JSON.stringify(r.b)&&(T.splice(t,1),t--)}}),T.forEach(function(e,r){for(let r=0;r<x.order[2].length;r++){const t=x.order[2][r];let o=JSON.parse(JSON.stringify(t));if(o.loop_id==e.id){let r=0,t=o.hop[0].branches.length-1,n=(e.b.length,e.b.length,e.b.length,new Array);for(let e=1;e<o.hop[0].branches.length;e++){let s=o.hop[0].branches[r],h={branchId:o.hop[0].branches[r+e].branchId,branchStr:o.hop[0].branches[r+e].branchStr,childNode:o.hop[0].branches[r+e].parentNode,childNodeStr:o.hop[0].branches[r+e].parentNodeStr,parentNode:o.hop[0].branches[r+e].childNode,parentNodeStr:o.hop[0].branches[r+e].childNodeStr,pathPos:o.hop[0].branches[r+e].pathPos};const l=I[I.length-1]+1;I.push(l);let i={loop_id:l,hop:[]};if(i.hop.push({id:0,branches:[s]}),i.hop.push({id:1,branches:[h]}),n.push(i),r==t-1)break;r+e==t&&(e=0,r++)}n.forEach(e=>{M.order[2].push({loop_id:e.loop_id,hop:e.hop})})}}});for(let e=3;e<x.order.length;e++)M.order[e]=x.order[e];let P=[];j.order[2]=M.order[2];for(let e=3;e<M.order.length;e++)j.order[e]=[],M.order[e].forEach(e=>{let r=e.hop.length,t=[];for(let o=0;o<r;o++){const r=e.hop[o];let n=r.branches.length,s=n-1,h=t.length-1;if(h>=0){let e=t.length,o=t[h].length,l=n,i=t.slice(),a=new Array(s);for(let e=0;e<a.length;e++)a[e]=i;let d=[];for(let r=0;r<e+1;r++){d[r]=[];for(let e=0;e<o*(s+1);e++)d[r][e]=null}for(let e=0;e<i.length;e++){const r=i[e];for(let t=0;t<r.length;t++){const o=r[t];d[e][t]=o}}let c=i[0].length;for(let e=0;e<a.length;e++){const r=a[e];for(let t=0;t<r.length;t++){const o=r[t];for(let r=0;r<o.length;r++){const n=o[r];d[t][r+c*(e+1)]=n}}}for(let t=0;t<l;t++){let o=r.branches[t];for(let r=0;r<c;r++)d[e][t*c+r]=o}t=d.slice()}else{let e=[];for(let t=0;t<r.branches.length;t++){const o=r.branches[t];e.push(o)}t.push(e)}}P.push(t)});P.forEach(e=>{let r=I[I.length-1],t=e.length,o=t,n=e[0].length,s=[];for(let h=0;h<n;h++){let n=new Array(o),l={loop_id:++r,hop:[]};for(let r=0;r<o;r++){const t=e[r];n[r]=t[h],l.hop.push({id:r,branches:[t[h]]})}s.push(n),j.order[t].push(l)}}),console.log("Meshes-finder finished the job...");let q=0;console.log("Search Results:");let C={count:[],total:0};switch(j.order.forEach(function(e,r){r>1&&(q+=e.length,console.log("Order "+r+": "+e.length)),C.count.push(e.length)}),C.total=q,C.ordermax=j.order.length-1,console.log("Found "+q+" Meshes in the circuit."),console.timeEnd("meshes-finder-duration"),e){case 0:{let e={order:new Array(j.order.length)};for(let r=0;r<j.order.length;r++){e.order[r]=[];const t=j.order[r];for(let o=0;o<t.length;o++){const n=t[o];let s=[];for(let e=0;e<n.hop.length;e++){const r=n.hop[e];s.push(r.branches[0].branchStr)}e.order[r].push(s)}}e.info=C,r=e;break}case 1:{let e={order:new Array(j.order.length)};for(let r=0;r<j.order.length;r++){e.order[r]=[];const t=j.order[r];for(let o=0;o<t.length;o++){const n=t[o];let s=[];for(let e=0;e<n.hop.length;e++){const r=n.hop[e];s.push({Branch:r.branches[0].branchStr,ParentNode:r.branches[0].parentNodeStr,ChildNode:r.branches[0].childNodeStr})}e.order[r].push(s)}}e.info=JSON.parse(JSON.stringify(C)),r=e;break}case 2:j.info=C,r=j;break;default:t.state=!0,t.reason.push("Invalid level of data detail. Available Options: 0 to 2, being 2 the most detailed.")}return{error:t,data:r}}}module.exports=MeshesFinder;